package uk.modl.parser;

import lombok.extern.log4j.Log4j2;
import org.antlr.v4.runtime.tree.ParseTree;
import org.apache.commons.lang3.tuple.ImmutablePair;
import uk.modl.model.*;
import uk.modl.parser.antlr.MODLParser;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

/**
 * Parser for a MODLParser.ModlContext object
 */
@Log4j2
public class ModlParsedVisitor {

    /**
     * Immutable result
     */
    public final Modl modl;

    /**
     * Constructor
     *
     * @param ctx a MODLParser.ModlContext generated by Antlr
     */
    public ModlParsedVisitor(final MODLParser.ModlContext ctx) {
        log.trace("ModlParsedVisitor()");

        final List<Structure> structures = ctx.modl_structure()
                .stream()
                .map(ModlParsedVisitor::visitStructure)
                .collect(Collectors.toList());

        modl = new Modl(structures);
    }

    /**
     * Parse Structures
     *
     * @param ctx the context
     * @return a Structure
     */
    private static Structure visitStructure(final MODLParser.Modl_structureContext ctx) {
        log.trace("visitStructure()");

        if (ctx.modl_array() != null) {
            return visitArray(ctx.modl_array());
        }
        if (ctx.modl_map() != null) {
            return visitMap(ctx.modl_map());
        }
        if (ctx.modl_pair() != null) {
            return visitPair(ctx.modl_pair());
        }
        if (ctx.modl_top_level_conditional() != null) {
            return visitTopLevelConditional(ctx.modl_top_level_conditional());
        }
        return null;
    }

    /**
     * Parse a TopLevelConditional
     *
     * @param ctx the context
     * @return a TopLevelConditional
     */
    private static TopLevelConditional visitTopLevelConditional(final MODLParser.Modl_top_level_conditionalContext ctx) {
        log.trace("visitTopLevelConditional()");

        final List<ConditionTest> tests = new ArrayList<>();
        final List<TopLevelConditionalReturn> returns = new ArrayList<>();
        if (ctx.modl_condition_test() != null) {
            tests.addAll(ctx.modl_condition_test()
                    .stream()
                    .map(ModlParsedVisitor::visitConditionTest)
                    .collect(Collectors.toList()));
        }
        if (ctx.modl_top_level_conditional_return() != null) {
            returns.addAll(ctx.modl_top_level_conditional_return()
                    .stream()
                    .map(ModlParsedVisitor::visitTopLevelConditionReturn)
                    .collect(Collectors.toList()));
        }
        assert tests.size() >= 1;
        assert returns.size() == tests.size();

        return new TopLevelConditional(tests, returns);
    }

    /**
     * Parse a MapConditional
     *
     * @param ctx the context
     * @return a MapConditional
     */
    private static MapConditional visitMapConditional(final MODLParser.Modl_map_conditionalContext ctx) {
        log.trace("visitMapConditional()");
        final List<ConditionTest> tests = new ArrayList<>();
        final List<MapConditionalReturn> returns = new ArrayList<>();
        if (ctx.modl_condition_test() != null) {
            tests.addAll(ctx.modl_condition_test()
                    .stream()
                    .map(ModlParsedVisitor::visitConditionTest)
                    .collect(Collectors.toList()));
        }
        if (ctx.modl_map_conditional_return() != null) {
            returns.addAll(ctx.modl_map_conditional_return()
                    .stream()
                    .map(ModlParsedVisitor::visitMapConditionalReturn)
                    .collect(Collectors.toList()));
        }
        assert tests.size() >= 1;
        assert returns.size() == tests.size();

        return new MapConditional(tests, returns);
    }

    /**
     * Parse a MapConditionalReturn
     *
     * @param ctx the context
     * @return a MapConditionalReturn
     */
    private static MapConditionalReturn visitMapConditionalReturn(final MODLParser.Modl_map_conditional_returnContext ctx) {
        log.trace("visitMapConditionalReturn()");
        final List<MapItem> items = ctx.modl_map_item()
                .stream()
                .map(ModlParsedVisitor::visitMapItem)
                .collect(Collectors.toList());
        return new MapConditionalReturn(items);
    }

    /**
     * Parse a TopLevelConditionalReturn
     *
     * @param ctx the context
     * @return a TopLevelConditionalReturn
     */
    private static TopLevelConditionalReturn visitTopLevelConditionReturn(final MODLParser.Modl_top_level_conditional_returnContext ctx) {
        log.trace("visitTopLevelConditionReturn()");

        final List<Structure> structures = new ArrayList<>();
        if (ctx.modl_structure() != null) {
            structures.addAll(ctx.modl_structure()
                    .stream()
                    .map(ModlParsedVisitor::visitStructure)
                    .collect(Collectors.toList()));
        }

        return new TopLevelConditionalReturn(structures);
    }

    /**
     * Parse a ConditionTest
     *
     * @param ctx the context
     * @return a ConditionTest
     */
    private static ConditionTest visitConditionTest(final MODLParser.Modl_condition_testContext ctx) {
        log.trace("visitConditionTest()");

        final List<ImmutablePair<ConditionOrConditionGroupInterface, String>> subConditionList = new ArrayList<>();

        String lastOperator = null;
        boolean shouldNegate = false;
        for (final ParseTree child : ctx.children) {
            if (child instanceof MODLParser.Modl_condition_groupContext) {
                if (shouldNegate) {
                    final NegatedConditionGroup conditionGroup = visitNegatedConditionGroup((MODLParser.Modl_condition_groupContext) child);
                    subConditionList.add(new ImmutablePair<>(conditionGroup, lastOperator));
                } else {
                    final ConditionGroup conditionGroup = visitConditionGroup((MODLParser.Modl_condition_groupContext) child);
                    subConditionList.add(new ImmutablePair<>(conditionGroup, lastOperator));
                }

                lastOperator = null;
                shouldNegate = false;
            } else if (child instanceof MODLParser.Modl_conditionContext) {
                if (shouldNegate) {
                    final NegatedCondition condition = visitNegatedCondition(((MODLParser.Modl_conditionContext) child));
                    subConditionList.add(new ImmutablePair<>(condition, lastOperator));
                } else {
                    final Condition condition = visitCondition((MODLParser.Modl_conditionContext) child);
                    subConditionList.add(new ImmutablePair<>(condition, lastOperator));
                }

                lastOperator = null;
                shouldNegate = false;
            } else {
                if (child
                        .getText()
                        .equals("!")) {
                    shouldNegate = true;
                } else {
                    lastOperator = child.getText();
                }
            }

        }

        return new ConditionTest(subConditionList);
    }

    /**
     * Parse a ConditionGroup
     *
     * @param ctx the context
     * @return a ConditionGroup
     */
    private static ConditionGroup visitConditionGroup(final MODLParser.Modl_condition_groupContext ctx) {
        log.trace("visitConditionGroup()");
        final List<ImmutablePair<ConditionTest, String>> subConditionList = handleConditionGroup(ctx);
        return new ConditionGroup(subConditionList);
    }

    /**
     * Convert a ConditionGroup context to a list of subconditions
     *
     * @param ctx the context
     * @return a list of subconditions
     */
    private static List<ImmutablePair<ConditionTest, String>> handleConditionGroup(final MODLParser.Modl_condition_groupContext ctx) {
        final List<ImmutablePair<ConditionTest, String>> subConditionList = new ArrayList<>();

        String lastOperator = null;
        for (final ParseTree child : ctx.children) {
            if (child instanceof MODLParser.Modl_condition_testContext) {
                final ConditionTest conditionGroup = visitConditionTest((MODLParser.Modl_condition_testContext) child);
                subConditionList.add(new ImmutablePair<>(conditionGroup, lastOperator));

                lastOperator = null;
            } else {
                lastOperator = child.getText();
            }
        }
        return subConditionList;
    }

    /**
     * Parse a ConditionGroup
     *
     * @param ctx the context
     * @return a ConditionGroup
     */
    private static NegatedConditionGroup visitNegatedConditionGroup(final MODLParser.Modl_condition_groupContext ctx) {
        log.trace("visitNegatedConditionGroup()");
        final List<ImmutablePair<ConditionTest, String>> subConditionList = handleConditionGroup(ctx);
        return new NegatedConditionGroup(subConditionList);
    }

    /**
     * Parse a Condition
     *
     * @param ctx the context
     * @return a Condition
     */
    private static Condition visitCondition(final MODLParser.Modl_conditionContext ctx) {
        log.trace("visitCondition()");
        final Operator op = (ctx.modl_operator() != null) ? visitOperator(ctx.modl_operator()) : null;

        final List<ValueItem> values = (ctx.modl_value() != null) ? ctx.modl_value()
                .stream()
                .map(ModlParsedVisitor::visitValue)
                .collect(Collectors.toList()) : Collections.emptyList();

        return new Condition(op, values);
    }

    /**
     * Parse a Condition
     *
     * @param ctx the context
     * @return a Condition
     */
    private static NegatedCondition visitNegatedCondition(final MODLParser.Modl_conditionContext ctx) {
        log.trace("visitNegatedCondition()");
        final Operator op = (ctx.modl_operator() != null) ? visitOperator(ctx.modl_operator()) : null;

        final List<ValueItem> values = (ctx.modl_value() != null) ? ctx.modl_value()
                .stream()
                .map(ModlParsedVisitor::visitValue)
                .collect(Collectors.toList()) : Collections.emptyList();

        return new NegatedCondition(op, values);
    }

    /**
     * Parse an Operator
     *
     * @param ctx the context
     * @return an Operator
     */
    private static Operator visitOperator(final MODLParser.Modl_operatorContext ctx) {
        log.trace("visitOperator()");

        final boolean equals = ctx.EQUALS() != null;
        final boolean negate = ctx.EXCLAM() != null;
        final boolean gthan = ctx.GTHAN() != null;
        final boolean lthan = ctx.LTHAN() != null;

        if (equals) {
            if (gthan) {
                return new GreaterThanOrEqualsOperator();
            }
            if (lthan) {
                return new LessThanOrEqualsOperator();
            }
            if (negate) {
                return new NotEqualsOperator();
            }
            return new EqualsOperator();
        }
        if (gthan) {
            return new GreaterThanOperator();
        }
        if (lthan) {
            return new LessThanOperator();
        }
        return null;// Should never get here unless the grammar changes.
    }

    /**
     * Parse ModlArrays
     *
     * @param ctx the context
     * @return a list of ArrayItems
     */
    private static Array visitArray(final MODLParser.Modl_arrayContext ctx) {
        log.trace("visitArray()");

        final List<ArrayItem> items = ctx.modl_array_item()
                .stream()
                .map(ModlParsedVisitor::visitArrayItem)
                .collect(Collectors.toList());

        items.addAll(ctx.modl_nb_array()
                .stream()
                .map(ModlParsedVisitor::visitNbArray)
                .collect(Collectors.toList()));

        return new Array(items);
    }

    /**
     * Parse NbArrays
     *
     * @param ctx the context
     * @return a list of ArrayItems
     */
    private static Array visitNbArray(final MODLParser.Modl_nb_arrayContext ctx) {
        log.trace("visitNbArray()");

        final List<ArrayItem> items = ctx.modl_array_item()
                .stream()
                .map(ModlParsedVisitor::visitArrayItem)
                .collect(Collectors.toList());

        return new Array(items);
    }

    /**
     * Parse ArrayItems
     *
     * @param ctx the context
     * @return a list of ArrayItems
     */
    private static ArrayItem visitArrayItem(final MODLParser.Modl_array_itemContext ctx) {
        log.trace("visitArrayItem()");
        if (ctx.modl_array_conditional() != null) {
            return visitArrayConditional(ctx.modl_array_conditional());
        }
        if (ctx.modl_array_value_item() != null) {
            return visitArrayValueItem(ctx.modl_array_value_item());
        }
        return null;
    }

    /**
     * Parse ArrayValue
     *
     * @param ctx the context
     * @return an ArrayItem
     */
    private static ArrayItem visitArrayValueItem(final MODLParser.Modl_array_value_itemContext ctx) {
        log.trace("visitArrayValueItem()");
        if (ctx.modl_array() != null) {
            return visitArray(ctx.modl_array());
        }
        if (ctx.modl_map() != null) {
            return visitMap(ctx.modl_map());
        }
        if (ctx.modl_pair() != null) {
            return visitPair(ctx.modl_pair());
        }
        if (ctx.modl_primitive() != null) {
            return (ArrayItem) visitPrimitive(ctx.modl_primitive());
        }
        return null;
    }

    /**
     * Parse ArrayConditionalContext
     *
     * @param ctx the context
     * @return an ArrayItem
     */
    private static ArrayConditional visitArrayConditional(final MODLParser.Modl_array_conditionalContext ctx) {
        log.trace("visitArrayConditional()");
        final List<ConditionTest> tests = new ArrayList<>();
        final List<ArrayConditionalReturn> returns = new ArrayList<>();
        if (ctx.modl_condition_test() != null) {
            tests.addAll(ctx.modl_condition_test()
                    .stream()
                    .map(ModlParsedVisitor::visitConditionTest)
                    .collect(Collectors.toList()));
        }
        if (ctx.modl_array_conditional_return() != null) {
            returns.addAll(ctx.modl_array_conditional_return()
                    .stream()
                    .map(ModlParsedVisitor::visitArrayConditionalReturn)
                    .collect(Collectors.toList()));
        }
        assert tests.size() >= 1;
        assert returns.size() == tests.size();

        return new ArrayConditional(tests, returns);
    }

    /**
     * Parse ArrayConditionalReturn
     *
     * @param ctx the context
     * @return an ArrayConditionalReturn
     */
    private static ArrayConditionalReturn visitArrayConditionalReturn(final MODLParser.Modl_array_conditional_returnContext ctx) {
        log.trace("visitMapConditionalReturn()");
        final List<ArrayItem> items = ctx.modl_array_item()
                .stream()
                .map(ModlParsedVisitor::visitArrayItem)
                .collect(Collectors.toList());
        return new ArrayConditionalReturn(items);
    }

    /**
     * Parse ModlMaps
     *
     * @param ctx the context
     * @return a list of MapItems
     */
    private static Map visitMap(final MODLParser.Modl_mapContext ctx) {
        log.trace("visitMap()");

        final List<MapItem> items = ctx.modl_map_item()
                .stream()
                .map(ModlParsedVisitor::visitMapItem)
                .collect(Collectors.toList());

        return new Map(items);
    }

    /**
     * Parse MapItems
     *
     * @param ctx the context
     * @return a MapItem
     */
    private static MapItem visitMapItem(MODLParser.Modl_map_itemContext ctx) {
        log.trace("visitMapItem()");
        if (ctx.modl_pair() != null) {
            return visitPair(ctx.modl_pair());
        }
        if (ctx.modl_map_conditional() != null) {
            return visitMapConditional(ctx.modl_map_conditional());
        }
        return null;
    }

    /**
     * Parse a ModlPair
     *
     * @param ctx the context
     * @return a Pair
     */
    private static Pair visitPair(final MODLParser.Modl_pairContext ctx) {
        log.trace("visitPair()");
        final String key = (ctx.QUOTED() != null) ? ctx.QUOTED()
                .getText() : (ctx.STRING() != null) ? ctx.STRING()
                .getText() : null;

        final PairValue value;
        if (ctx.modl_array() != null) {
            value = visitArray(ctx.modl_array());
        } else if (ctx.modl_map() != null) {
            value = visitMap(ctx.modl_map());
        } else if (ctx.modl_value_item() != null) {
            value = visitValueItem(ctx.modl_value_item());
        } else {
            value = null;
        }
        return new Pair(key, value);
    }

    /**
     * Parse ValueItems
     *
     * @param ctx the context
     * @return a ValueItem
     */
    private static ValueItem visitValueItem(final MODLParser.Modl_value_itemContext ctx) {
        log.trace("visitValueItem()");
        if (ctx.modl_value() != null) {
            return visitValue(ctx.modl_value());
        }
        if (ctx.modl_value_conditional() != null) {
            return visitValueConditional(ctx.modl_value_conditional());
        }
        return null;
    }

    /**
     * Parse ValueConditional
     *
     * @param ctx the context
     * @return a ValueItem
     */
    private static ValueConditional visitValueConditional(final MODLParser.Modl_value_conditionalContext ctx) {
        log.trace("visitValueConditional()");
        final List<ConditionTest> tests = new ArrayList<>();
        final List<ValueConditionalReturn> returns = new ArrayList<>();
        if (ctx.modl_condition_test() != null) {
            tests.addAll(ctx.modl_condition_test()
                    .stream()
                    .map(ModlParsedVisitor::visitConditionTest)
                    .collect(Collectors.toList()));
        }
        if (ctx.modl_value_conditional_return() != null) {
            returns.addAll(ctx.modl_value_conditional_return()
                    .stream()
                    .map(ModlParsedVisitor::visitValueConditionReturn)
                    .collect(Collectors.toList()));
        }
        assert tests.size() >= 1;
        assert returns.size() == (1 + tests.size());

        return new ValueConditional(tests, returns);
    }

    /**
     * Parse ValueConditionalReturn
     *
     * @param ctx the context
     * @return a ValueConditionalReturn
     */
    private static ValueConditionalReturn visitValueConditionReturn(final MODLParser.Modl_value_conditional_returnContext ctx) {
        log.trace("visitValueConditionalReturn()");

        final List<ValueItem> items = ctx.modl_value_item()
                .stream()
                .map(ModlParsedVisitor::visitValueItem)
                .collect(Collectors.toList());

        return new ValueConditionalReturn(items);
    }

    /**
     * Parse Values
     *
     * @param ctx the context
     * @return a Value
     */
    private static ValueItem visitValue(final MODLParser.Modl_valueContext ctx) {
        log.trace("visitValue()");
        if (ctx.modl_array() != null) {
            return visitArray(ctx.modl_array());
        }
        if (ctx.modl_map() != null) {
            return visitMap(ctx.modl_map());
        }
        if (ctx.modl_pair() != null) {
            return visitPair(ctx.modl_pair());
        }
        if (ctx.modl_nb_array() != null) {
            return visitNbArray(ctx.modl_nb_array());
        }
        if (ctx.modl_primitive() != null) {
            return visitPrimitive(ctx.modl_primitive());
        }
        return null;
    }

    /**
     * Parse Primitive
     *
     * @param ctx the context
     * @return a ValueItem
     */
    private static ValueItem visitPrimitive(final MODLParser.Modl_primitiveContext ctx) {
        log.trace("visitPrimitive()");

        if (ctx.FALSE() != null) {
            return FalsePrimitive.instance;
        }
        if (ctx.TRUE() != null) {
            return TruePrimitive.instance;
        }
        if (ctx.STRING() != null) {
            return new StringPrimitive(ctx.STRING()
                    .getText());
        }
        if (ctx.NULL() != null) {
            return NullPrimitive.instance;
        }
        if (ctx.NUMBER() != null) {
            return new NumberPrimitive(ctx.NUMBER()
                    .getText());
        }
        if (ctx.QUOTED() != null) {
            return new StringPrimitive(ctx.QUOTED()
                    .getText());
        }
        return null;
    }
}
